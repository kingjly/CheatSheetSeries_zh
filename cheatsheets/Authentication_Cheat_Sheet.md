# 身份认证备忘录

## 引言

**身份认证**（**AuthN**）是通过验证一个或多个身份验证器（如密码、指纹或安全令牌）的有效性，来确认个人、实体或网站是其声称的身份的过程。

**数字身份**是参与在线交易的主体的唯一表示。数字身份在数字服务的上下文中始终是唯一的，但不一定需要可追溯到特定的现实生活主体。

**身份验证**旨在确立主体确实是其声称的身份。这个概念与了解客户（KYC）的概念相关，其目标是将数字身份与真实的人绑定。

**会话管理**是服务器维护与其交互的实体状态的过程。这要求服务器在整个事务过程中记住如何响应后续请求。会话通过会话标识符在服务器上维护，该标识符可以在客户端和服务器之间来回传递以发送和接收请求。会话应该对每个用户是唯一的，并且在计算上极难预测。[会话管理备忘录](Session_Management_Cheat_Sheet.md)包含了该领域的最佳实践指南。

## 身份认证通用指南

### 用户 ID

用户 ID 的主要功能是在系统中唯一标识用户。理想情况下，用户 ID 应该随机生成，以防止创建可预测或连续的 ID，这可能构成安全风险，尤其是在用户 ID 可能暴露或从外部来源推断的系统中。

### 用户名

用户名是用户选择的易于记忆的标识符，用于在登录系统或服务时识别自己。如果用户选择的用户名也作为其在系统中的唯一标识符，则用户 ID 和用户名这两个术语可能会互换使用。

用户应该被允许使用其电子邮件地址作为用户名，前提是在注册期间验证了电子邮件。此外，他们应该有选择除电子邮件地址之外的用户名的选项。关于验证电子邮件地址的更多信息，请访问[输入验证备忘录中的电子邮件讨论](Input_Validation_Cheat_Sheet.md#email-address-validation)。

### 身份认证解决方案和敏感账户

- **不要**允许使用敏感账户（即在解决方案内部使用的账户，如后端/中间件/数据库）登录任何前端用户界面
- **不要**对不安全访问（如公共访问/DMZ）使用内部使用的相同身份认证解决方案（如身份提供者/活动目录）

### 实施适当的密码强度控制

使用密码进行身份认证时，密码强度是一个关键考虑因素。"强"密码策略使得通过手动或自动方式猜测密码变得困难甚至不可能。以下特征定义了强密码：

- 密码长度
    - 应用程序应**强制执行**密码的**最小**长度。**少于8个字符**的密码被认为是弱密码（[NIST SP800-63B](https://pages.nist.gov/800-63-3/sp800-63b.html)）。
    - 密码的**最大**长度应**至少为64个字符**，以允许使用通行短语（[NIST SP800-63B](https://pages.nist.gov/800-63-3/sp800-63b.html)）。请注意，某些哈希算法的实现可能导致[长密码拒绝服务](https://www.acunetix.com/vulnerabilities/web/long-password-denial-of-service/)。
- 不要静默截断密码。[密码存储备忘录](Password_Storage_Cheat_Sheet.md#maximum-password-lengths)提供了关于如何处理超过最大长度的密码的进一步指导。
- 允许使用**所有**字符，包括 Unicode 和空白。不应有限制允许字符类型的密码组成规则。不应要求大小写、数字或特殊字符。
- 在发生密码泄露或识别到泄露时，确保凭据轮换。
- 包含密码强度计，帮助用户创建更复杂的密码并阻止常见和之前已泄露的密码
    - 可以使用 [zxcvbn-ts 库](https://github.com/zxcvbn-ts/zxcvbn) 实现此目的。
    - [Pwned Passwords](https://haveibeenpwned.com/Passwords) 是一个可以检查密码是否已被泄露的服务。您可以自行托管或使用 [API](https://haveibeenpwned.com/API/v3#PwnedPasswords)。

#### 更多详细信息请查看

- [ASVS v4.0 密码安全要求](https://github.com/OWASP/ASVS/blob/master/4.0/en/0x11-V2-Authentication.md#v21-password-security-requirements)
- [密码演进：现代时代的身份认证指南](https://www.troyhunt.com/passwords-evolved-authentication-guidance-for-the-modern-era/)

### 实施安全的密码恢复机制

应用程序通常会提供一种机制，使用户在忘记密码时能够重新访问其账户。有关此功能的详细信息，请参见[忘记密码备忘录](Forgot_Password_Cheat_Sheet.md)。

### 安全地存储密码

对于应用程序来说，使用正确的加密技术存储密码至关重要。有关此功能的详细信息，请参见[密码存储备忘录](Password_Storage_Cheat_Sheet.md)。

### 使用安全函数比较密码哈希

在可能的情况下，应使用语言或框架提供的安全密码比较函数（如 PHP 中的 [password_verify()](https://www.php.net/manual/en/function.password-verify.php) 函数）将用户提供的密码与存储的密码哈希进行比较。如果无法做到这一点，请确保比较函数：

- 具有最大输入长度，以防止使用非常长的输入进行拒绝服务攻击。
- 显式设置两个变量的类型，以防止类型混淆攻击，如 PHP 中的[魔术哈希](https://www.whitehatsec.com/blog/magic-hashes/)。
- 以恒定时间返回，以防止时间攻击。

### 更改密码功能

在开发更改密码功能时，确保：

- 用户已通过活动会话进行身份认证。
- 验证当前密码。这是为了确保是合法用户在更改密码。滥用场景是：合法用户在公共计算机上登录。该用户忘记退出。然后另一个人使用这台公共计算机。如果我们不验证当前密码，这个人可能能够更改密码。

### 仅通过 TLS 或其他强传输传输密码

参见：[传输层安全备忘录](Transport_Layer_Security_Cheat_Sheet.md)

登录页面和所有后续经过身份认证的页面必须仅通过 TLS 或其他强传输访问。未能为登录页面使用 TLS 或其他强传输允许攻击者修改登录表单操作，导致用户凭据被发布到任意位置。未能为登录后的经过身份认证的页面使用 TLS 或其他强传输使攻击者能够查看未加密的会话 ID 并破坏用户的经过身份认证的会话。

### 对敏感功能要求重新认证

为了缓解 CSRF 和会话劫持，在更新敏感的账户信息（如用户的密码或电子邮件地址）或进行敏感交易（如将购买发送到新地址）之前，要求提供账户的当前凭据非常重要。没有这种对策，攻击者可能通过 CSRF 或 XSS 攻击执行敏感交易，而无需知道用户的当前凭据。此外，攻击者可能获得用户浏览器的临时物理访问权或窃取其会话 ID 以接管用户会话。

### 考虑强事务认证

某些应用程序应使用第二因素来检查用户是否可以执行敏感操作。更多信息，请参见[事务授权备忘录](Transaction_Authorization_Cheat_Sheet.md)。

#### TLS 客户端认证

TLS 客户端认证，也称为双向 TLS 认证，包括浏览器和服务器在 TLS 握手过程中发送各自的 TLS 证书。就像通过使用证书并询问可验证的有效证书颁发机构（CA）证书是否有效来验证服务器的真实性一样，服务器可以通过接收来自客户端的证书并针对第三方 CA 或其自身 CA 进行验证来认证用户。为此，服务器必须为用户提供专门为其生成的证书，为主题分配值，以便可以用于确定证书应验证哪个用户。用户在浏览器上安装证书，现在将其用于网站。

在以下情况下使用这种方法是个好主意：

- 用户仅从单台计算机/浏览器访问网站是可接受的（甚至是首选）。
- 用户不会被在浏览器上安装 TLS 证书的过程吓倒，或者会有人（可能是 IT 支持）为用户执行此操作。
- 网站需要额外的安全步骤。
- 在公司或组织的内部网站上使用也是个好主意。

对于广泛和公开可用的网站（将拥有普通用户），通常不建议使用此方法。例如，在像 Facebook 这样的网站上实施这种方法并不是个好主意。虽然这种技术可以防止用户输入密码（从而防止普通键盘记录器窃取），但仍然建议考虑同时使用密码和 TLS 客户端认证。

另外，如果客户端位于执行 SSL/TLS 解密的企业代理后面，除非在代理上允许该站点，否则这将破坏证书认证。

更多信息，请参见：[客户端认证的 TLS 握手](https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake)

### 身份认证和错误消息

身份认证功能中错误实现的错误消息可用于用户 ID 和密码枚举。应用程序应以通用方式响应（包括 HTTP 和 HTML）。

#### 身份验证响应

使用任何身份验证机制（登录、密码重置或密码恢复），应用程序必须返回一个通用的错误消息，无论是否出现以下情况：

- 用户 ID 或密码不正确。
- 账户不存在。
- 账户被锁定或禁用。

还应考虑用户注册功能，对于用户已存在的情况，也可以应用相同的通用错误消息方法。

目的是防止创建[差异因素](https://cwe.mitre.org/data/definitions/204.html)，阻止攻击者对应用程序进行用户枚举攻击。

值得注意的是，业务逻辑本身可能会带来与处理时间相关的差异因素。事实上，根据实现方式的不同，处理时间可能会因成功和失败的情况而显著不同，从而允许攻击者发起[基于时间的攻击](https://en.wikipedia.org/wiki/Timing_attack)（例如，几秒钟的时间差）。

使用伪代码的登录功能示例：

- 使用"快速退出"方法的第一种实现

```text
IF USER_EXISTS(username) THEN
    password_hash=HASH(password)
    IS_VALID=LOOKUP_CREDENTIALS_IN_STORE(username, password_hash)
    IF NOT IS_VALID THEN
        RETURN Error("Invalid Username or Password!")
    ENDIF
ELSE
   RETURN Error("Invalid Username or Password!")
ENDIF
```

可以清楚地看出，如果用户不存在，应用程序将直接抛出错误。而当用户存在但密码不正确时，在返回错误之前会有更多的处理过程。因此，响应时间对于相同的错误会有所不同，使攻击者能够区分错误的用户名和错误的密码。

- 不依赖"快速退出"方法的第二种实现：

```text
password_hash=HASH(password)
IS_VALID=LOOKUP_CREDENTIALS_IN_STORE(username, password_hash)
IF NOT IS_VALID THEN
   RETURN Error("Invalid Username or Password!")
ENDIF
```

这段代码无论用户名或密码是什么，都会经历相同的处理过程，使应用程序能够在大致相同的响应时间内返回结果。

对于返回通用错误消息，用户体验（UX）是一个需要考虑的问题。合法用户可能会对通用消息感到困惑，这会使他们难以使用应用程序，并且在多次重试后可能会因复杂性而放弃应用程序。返回*通用错误消息*的决定可以根据应用程序及其数据的关键程度来确定。例如，对于关键应用程序，团队可以决定在失败场景下，用户将始终被重定向到支持页面，并返回*通用错误消息*。

关于用户枚举本身，[防止暴力破解攻击](#防止自动化攻击)也很有效，因为它可以防止攻击者大规模地进行枚举。可以在无法返回*通用错误消息*且必须保留*用户体验*的功能上应用[验证码](https://en.wikipedia.org/wiki/CAPTCHA)。

##### 不正确和正确的响应示例

###### 登录

不正确的响应示例：

- "用户 foo 登录：密码无效。"
- "登录失败，无效的用户 ID。"
- "登录失败；账户已禁用。"
- "登录失败；此用户未激活。"

正确的响应示例：

- "登录失败；无效的用户 ID 或密码。"

###### 密码恢复

不正确的响应示例：

- "我们刚刚向您发送了密码重置链接。"
- "此电子邮件地址在我们的数据库中不存在。"

正确的响应示例：

- "如果该电子邮件地址在我们的数据库中，我们将向您发送重置密码的邮件。"

###### 账户创建

不正确的响应示例：

- "此用户 ID 已被使用。"
- "欢迎！您已成功注册。"

正确的响应示例：

- "激活账户的链接已发送到您提供的邮件地址。"

##### 错误代码和 URL

应用程序可能根据身份验证尝试的响应返回不同的 [HTTP 错误代码](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)。对于正面结果可能返回 200，对于负面结果可能返回 403。即使向用户显示通用错误页面，HTTP 响应代码可能不同，这可能泄露账户是否有效的信息。

错误披露也可以作为差异因素，请查阅[错误处理备忘录](Error_Handling_Cheat_Sheet.md)，了解应用程序中不同错误的全局处理方法。

### 防止自动化攻击

攻击者可以使用多种不同类型的自动化攻击来尝试破坏用户账户。下面列出了最常见的类型：

| 攻击类型 | 描述 |
|-------------|-------------|
| 暴力破解 | 针对单个账户测试来自字典或其他来源的多个密码。 |
| 凭证填充 | 测试从另一个网站泄露的用户名/密码组合。 |
| 密码喷洒 | 对大量不同账户测试单个弱密码。|

可以实施不同的保护机制来防御这些攻击。在许多情况下，这些防御并不能提供完全保护，但当采用深度防御方法实施多种防御时，可以达到合理的保护水平。

以下章节将主要关注防止暴力破解攻击，尽管这些控制措施对其他类型攻击也有效。关于防御凭证填充和密码喷洒的进一步指导，请参见[凭证填充防御备忘录](Credential_Stuffing_Prevention_Cheat_Sheet.md)。

#### 多因素认证

多因素认证（MFA）是防御大多数与密码相关攻击的最佳防御手段，包括暴力破解攻击。微软的分析表明，MFA 可以阻止 [99.9% 的账户入侵](https://techcommunity.microsoft.com/t5/Azure-Active-Directory-Identity/Your-Pa-word-doesn-t-matter/ba-p/731984)。因此，应尽可能实施；但是，根据应用程序的目标用户，强制使用 MFA 可能并不实际或可行。

[多因素认证备忘录](Multifactor_Authentication_Cheat_Sheet.md)包含了实施 MFA 的进一步指导。

#### 登录限流

登录限流是一种防止攻击者通过正常交互方式猜测密码的协议，包括：

- 最大尝试次数。

##### 账户锁定

防御这些攻击最常见的方法是实施账户锁定，即在一定数量的登录失败后，在一段时间内阻止任何登录尝试。

失败登录次数的计数器应与账户本身关联，而不是源 IP 地址，以防止攻击者从大量不同 IP 地址发起登录尝试。在实施账户锁定策略时，需要考虑多个因素，以在安全性和可用性之间找到平衡：

- 锁定前的失败尝试次数（锁定阈值）。
- 这些尝试必须发生的时间段（观察窗口）。
- 账户被锁定的时长（锁定持续时间）。

与实施固定锁定持续时间（例如十分钟）不同，一些应用程序使用指数锁定，即锁定持续时间从很短的时间（例如一秒）开始，并在每次失败登录尝试后成倍增加。

- 每次账户锁定后延迟的时间（最多 2-3 次，之后永久锁定账户）。

在设计账户锁定系统时，必须小心防止其被用于对其他用户账户进行拒绝服务攻击。一种方法是允许使用忘记密码功能的用户登录，即使账户已被锁定。

#### 验证码

使用有效的验证码可以帮助防止针对账户的自动化登录尝试。然而，许多验证码实现存在弱点，可以通过自动技术解决，或者可以外包给可以解决验证码的服务。因此，验证码的使用应被视为深度防御控制，使暴力破解攻击更加耗时和昂贵，而不是完全的预防措施。

可能对用户更友好的做法是，仅在少量登录失败后要求解决验证码，而不是从第一次登录就要求。

#### 安全问题和记忆词

添加安全问题或记忆词也可以帮助防御自动化攻击，尤其是在要求用户输入词中随机选择的字符时。需要注意的是，这**不**构成多因素认证，因为两个因素都是相同的（知道的事物）。此外，安全问题通常较弱且答案可预测，因此必须谨慎选择。[选择和使用安全问题备忘录](Choosing_and_Using_Security_Questions_Cheat_Sheet.md)包含了进一步的指导。

## 日志记录和监控

启用身份验证功能的日志记录和监控，以实时检测攻击/失败

- 确保记录和审查所有失败情况
- 确保记录和审查所有密码失败情况
- 确保记录和审查所有账户锁定情况

## 使用无需密码的身份验证协议

虽然通过用户名、密码和多因素认证的组合进行身份验证通常被认为是安全的，但在某些用例中，这并不被视为最佳选择或安全。例如，第三方应用程序希望从移动设备、其他网站、桌面或其他情况连接到 Web 应用程序。在这种情况下，允许第三方应用程序存储用户/密码组合是不安全的，因为这会将攻击面扩展到不受你控制的地方。对于这种情况和其他用例，有几种身份验证协议可以保护你免于向攻击者暴露用户数据。

### OAuth

开放授权（OAuth）是一种协议，允许应用程序以用户身份对服务器进行身份验证，无需密码或任何作为身份提供者的第三方服务器。它使用服务器生成的令牌，并提供授权流程，使客户端（如移动应用程序）可以告诉服务器正在使用服务的用户。

建议使用并实施 [OAuth 2.0](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics)，因为最初的版本（OAuth1.0）被发现容易受到会话固定攻击。

OAuth 2.0 依赖 HTTPS 进行安全，目前被 Facebook、Google、Twitter 和 Microsoft 等公司的 API 使用和实施。OAuth 1.0a 使用起来更加困难，因为它需要使用加密库进行数字签名。然而，由于 OAuth 1.0a 不依赖 HTTPS 进行安全，它可能更适合高风险交易。

### OpenId

OpenId 是一种基于 HTTP 的协议，使用身份提供者验证用户是否是他们所声称的身份。这是一个非常简单的协议，允许服务提供者发起的单点登录（SSO）方式。这使得用户可以重复使用提供给可信 OpenId 身份提供者的单一身份，并在多个网站上成为同一用户，而无需向除 OpenId 身份提供者之外的任何网站提供密码。

由于其简单性和密码保护，OpenId 已被广泛采用。一些著名的 OpenId 身份提供者包括 Stack Exchange、Google、Facebook 和 Yahoo!

对于非企业环境，只要身份提供者值得信赖，OpenId 被认为是一个安全且通常更好的选择。

### SAML

安全断言标记语言（SAML）常被认为与 OpenId 竞争。最推荐的版本是 2.0，因为它功能非常完整且提供强大的安全性。与 OpenId 类似，SAML 使用身份提供者，但与 OpenId 不同的是，它是基于 XML 的，并提供更多灵活性。SAML 基于浏览器重定向，发送 XML 数据。此外，SAML 不仅由服务提供者发起；还可以由身份提供者发起。这允许用户在不执行任何操作的情况下浏览不同的门户，同时保持身份验证，使过程透明。

虽然 OpenId 占据了大部分消费者市场，但 SAML 常常是企业应用程序的选择，因为很少有 OpenId 身份提供者被认为是企业级的（意味着他们验证用户身份的方式没有企业身份所需的高标准）。在内部网站中使用 SAML 更为常见，有时甚至使用内部网服务器作为身份提供者。

在过去几年中，像 SAP ERP 和 SharePoint（SharePoint 使用 Active Directory 联合服务 2.0）这样的应用程序已决定在需要 Web 服务和 Web 应用程序的企业联合时，使用 SAML 2.0 身份验证作为首选的单点登录实现方法。

**另请参见：[SAML 安全备忘录](SAML_Security_Cheat_Sheet.md)**

### FIDO

快速在线身份（FIDO）联盟创建了两种协议来促进在线身份验证：通用认证框架（UAF）协议和通用第二因素（U2F）协议。虽然 UAF 专注于无密码认证，但 U2F 允许为现有基于密码的认证添加第二因素。两种协议都基于公钥密码学的挑战-响应模型。

UAF 利用设备上现有的安全技术进行认证，包括指纹传感器、摄像头（面部生物识别）、麦克风（语音生物识别）、可信执行环境（TEEs）、安全元件（SEs）等。该协议旨在将这些设备功能插入通用认证框架。UAF 适用于原生应用程序和 Web 应用程序。

U2F 使用硬件令牌（通常是 USB）增强基于密码的认证，该令牌存储加密认证密钥并用于签名。用户可以在多个应用程序中使用相同的令牌作为第二因素。U2F 适用于 Web 应用程序。它通过使用网站的 URL 查找存储的认证密钥，提供**防钓鱼**保护。

## 密码管理器

密码管理器是程序、浏览器插件或 Web 服务，可自动管理大量不同的凭证。大多数密码管理器具有帮助用户在网站上轻松使用的功能，方式包括：
(a) 将密码粘贴到登录表单中
-- 或 --
(b) 模拟用户输入。

Web 应用程序应通过遵循以下建议，不要不必要地增加密码管理器的使用难度：

- 对用户名和密码输入使用标准 HTML 表单，并使用适当的 `type` 属性。
- 避免使用基于插件的登录页面（如 Flash 或 Silverlight）。
- 实施合理的最大密码长度，至少 64 个字符，如[实施适当的密码强度控制部分](#实施适当的密码强度控制)中讨论的。
- 允许使用任何可打印字符作为密码。
- 允许用户粘贴到用户名、密码和多因素认证字段。
- 允许用户使用单次 `Tab` 键在用户名和密码字段之间导航。

## 更改用户注册邮箱地址

用户的电子邮件地址经常变更。以下是处理此类情况的推荐流程：

*注意：如果启用了[多因素认证](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html)，该过程的要求会更低，因为身份证明更强，不仅仅依赖于密码。*

### 启用多因素认证的推荐流程

1. 确认用户的认证 cookie/令牌有效性。如果无效，显示登录界面。
2. 向用户描述更改注册邮箱地址的流程。
3. 要求用户提交拟更改的新邮箱地址，确保符合系统规则。
4. 请求使用[多因素认证](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html)进行身份验证。
5. 将拟更改的新邮箱地址存储为待定更改。
6. 创建并存储**两个**时间限制的随机数（nonce）：(a) 系统管理员通知，(b) 用户确认。
7. 发送包含这些随机数链接的两封邮件：

    - 仅**通知的邮件**发送到当前地址，提醒用户即将更改并提供意外情况链接。

    - **需确认的邮件**发送到拟更改的新地址，指示用户确认更改并提供意外情况链接。

8. 根据链接响应进行相应处理。

### 未启用多因素认证的推荐流程

1. 确认用户的认证 cookie/令牌有效性。如果无效，显示登录界面。
2. 向用户描述更改注册邮箱地址的流程。
3. 要求用户提交拟更改的新邮箱地址，确保符合系统规则。
4. 请求用户提供当前密码以验证身份。
5. 将拟更改的新邮箱地址存储为待定更改。
6. 创建并存储三个时间限制的随机数：系统管理员通知、用户确认和依赖密码的额外步骤。
7. 发送包含这些随机数链接的两封邮件：

    - 发送到当前地址的**需确认的邮件**，指示用户确认更改并提供意外情况链接。

    - 发送到拟更改新地址的**单独确认邮件**，指示用户确认更改并提供意外情况链接。

8. 根据链接响应进行相应处理。

### 上述流程的注意事项

- 值得注意的是，Google 对仅由密码保护的账户采用不同方法 -- [当前邮箱地址仅收到通知邮件](https://support.google.com/accounts/answer/55393?hl=en)。这种方法存在风险，需要用户保持警惕。

- 定期进行社会工程学培训至关重要。系统管理员和帮助台工作人员应接受培训，遵循规定流程，识别和应对社会工程学攻击。请参考 [CISA 的"避免社会工程学和钓鱼攻击"](https://www.cisa.gov/news-events/news/avoiding-social-engineering-and-phishing-attacks)以获取指导。
