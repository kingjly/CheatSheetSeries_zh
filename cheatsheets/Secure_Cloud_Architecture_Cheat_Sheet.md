# 云架构安全备忘录

## 引言

本备忘录将讨论在创建和审查云架构时需要遵循的常见且必要的安全模式。每个章节将涵盖特定的安全准则或需要考虑的云设计决策。本文档针对中大型企业系统编写，因此将讨论一些对于较小型组织可能不必要的额外开销元素。

## 风险分析、威胁建模和攻击面评估

对于任何应用程序架构，了解风险和威胁对于适当的安全性至关重要。没有人能将整个预算或带宽都集中在安全上，因此正确分配安全资源是必要的。

因此，企业必须进行风险评估、威胁建模活动和攻击面评估，以识别以下内容：

- 应用程序可能面临的威胁
- 这些威胁实际转化为攻击的可能性
- 这些攻击可能针对的攻击面
- 由于此类攻击导致数据或功能丢失的业务影响

这些都是正确界定架构安全性所必需的。然而，这些主题需要更详细地讨论。使用下面的资源链接，作为健康安全架构对话的一部分进行进一步调查。

- [威胁建模备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Threat_Modeling_Cheat_Sheet.html)
- [攻击面分析备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Attack_Surface_Analysis_Cheat_Sheet.html)
- [CISA 网络风险评估](https://www.cisa.gov/sites/default/files/2023-02/22_1201_safecom_guide_to_cybersecurity_risk_assessment_508-r1.pdf)

## 公有和私有组件

### 安全对象存储

对象存储通常有以下数据访问选项：

- 使用内置的身份和访问管理（IAM）策略访问资源
- 使用加密签名的 URL 和 HTTP 请求
- 直接使用公共存储

#### IAM 访问

此方法涉及在临时或持久基础架构上运行的托管或自管理服务的间接访问。该基础架构包含持久的控制平面 IAM 凭证，代表用户与对象存储交互。当应用程序具有其他用户界面或数据系统、尽可能隐藏存储系统、或信息不应/不会被最终用户看到（元数据）时，此方法最佳。可以与 Web 身份验证和日志记录结合使用，以更好地跟踪和控制资源访问。此方法的关键安全隐患是依赖可能包含弱点的开发代码或策略。

|                优点                 |                       缺点                         |
|:-----------------------------------:|:--------------------------------------------------:|
|       无直接数据访问               |          可能使用广泛的 IAM 策略                  |
| 对象存储对用户不可见               | 凭证丢失会给控制平面 API 访问权限                 |
|   可识别和可记录的访问             |           凭证可能被硬编码                         |

对于敏感用户数据，此方法是可接受的，但必须遵循严格的编码和云最佳实践，以正确保护数据。

#### 签名 URL

对象存储的 URL 签名涉及静态或动态生成 URL 的方法，密码学地保证实体可以访问存储中的资源。当需要或首选直接访问特定用户文件且没有文件传输开销时，此方法最佳。建议仅对不太敏感的用户数据使用此方法。此方法可以安全，但有明显的缺点。如果签名 URL 生成方法是自定义的、动态的且可注入的，仍可能发生代码注入，并且任何人只要获得 URL 就可以匿名访问资源。开发人员还必须考虑签名 URL 是否以及何时过期，这增加了方法的复杂性。

|                    优点                   |                    缺点                   |
|:-----------------------------------------:|:-----------------------------------------:|
|        仅访问一个资源                    |              匿名访问                     |
| 对象存储对用户可见性最小                 |         任何人都可以通过 URL 访问         |
|           高效文件传输                   | 自定义代码可能存在注入可能性              |

#### 公共对象存储

**这不是资源存储和分发的推荐方法**，应仅用于公共、非敏感、通用资源。此存储方法将为威胁行为者提供对云环境的额外侦察，任何在此配置中存储的数据在任何时间段内都必须被视为公开访问（泄露给公众）。

|                 优点                |                 缺点                 |
|:-----------------------------------:|:------------------------------------:|
| 高效访问多个资源                    |     任何人都可以访问/无隐私          |
|       简单的公共文件共享            |  未经身份验证的对象访问              |
|                                     |  可见完整文件系统                    |
|                                     |     意外泄露存储信息                 |

### VPC 和子网

虚拟私有云（VPC）和公有/私有网络子网允许应用程序及其网络被分割成不同的部分，在云系统中增加安全层。与其他公有与私有的权衡不同，成熟的架构可能会整合这些组件中的大部分。下面将详细解释每个组件。

#### VPC

VPC 用于在应用程序内创建网络边界，使组件可以相互通信，类似于数据中心的物理网络。VPC 将由若干公有和私有子网组成。VPC 可用于：

- 在同一云账户中分隔整个应用程序。
- 将应用程序的大型组件分隔到具有隔离网络的不同 VPC 中。
- 在用于不同客户或数据集的重复应用程序之间创建分隔。

#### 公有子网

公有子网包含具有面向互联网存在的组件。子网将包含网络路由元素，允许子网内的组件直接连接到互联网。一些用例包括：

- 面向公众的资源，如前端 Web 应用程序。
- 应用程序的初始接触点，如负载均衡器和路由器。
- 开发者访问点，如[堡垒主机](https://aws-quickstart.github.io/quickstart-linux-bastion/)（注意，如果设计/部署不正确，这些可能非常不安全）。

#### 私有子网

私有子网包含不应直接访问互联网的组件。子网可能包含网络路由，将其连接到公有子网，以结构化和受保护的方式接收互联网流量。私有子网非常适合：

- 数据库和数据存储。
- 后端服务器和相关文件系统。
- 任何被认为对直接互联网访问过于敏感的内容。

#### 简单架构示例

考虑下面的简单架构图。一个 VPC 将包含应用程序的所有组件，但元素将根据其在系统中的角色位于特定子网中。与此应用程序交互的正常流程可能如下：

1. 通过某种互联网网关、API 网关或其他面向互联网的组件访问应用程序。
2. 此网关连接到公有子网中的负载均衡器或 Web 服务器。两个组件提供面向公众的功能并相应地进行安全保护。
3. 这些组件随后与其适当的后端对应组件交互，即位于私有 VPC 中的数据库或后端服务器。这些连接更加受限，防止对可能"脆弱"的后端系统的额外访问。

![VPC 图](../assets/Secure_Cloud_Architecture_VPC.png)

*注意：此图intentionally省略了子网接口的路由和 IAM 元素，以简化并保持服务提供商无关性。*

此架构防止较不强化的后端组件或高风险服务（如数据库）直接暴露在互联网上。它还提供公共功能访问互联网，以避免额外的路由开销。通过专注于入口点的安全性和分离功能，可以更轻松地保护此架构，将非公开或敏感信息放置在私有子网中，使外部方更难访问。

# 信任边界

信任边界是系统内组件之间的连接，在这些连接处组件必须做出信任决策。换句话说，这个边界是具有潜在不同信任级别的两个组件相遇的点。这些边界的规模可以从用户与应用程序交互的信任程度，到云架构中代码函数或组件之间验证特定声明的信任。

然而，一般来说，信任每个组件正确且安全地执行其功能就足够了。因此，信任边界可能发生在云组件之间的连接，以及应用程序和第三方元素（如最终用户和其他供应商）之间。

例如，考虑下面的架构。API 网关连接到计算实例（临时或持久），然后访问持久存储资源。另外，存在一个可以验证调用者的身份验证、授权和/或身份的服务器。这是 OAuth、IAM 或目录系统的通用表示，用于控制对这些资源的访问。此外，还有一个临时 IAM 服务器控制存储资源的访问（使用类似[IAM 访问](#iam-访问)部分的方法）。如图中的虚线所示，即使许多或所有元素可能在同一应用程序中，信任边界也存在于每个计算组件、API 网关和认证/身份服务器之间。

![信任边界](../assets/Secure_Cloud_Architecture_Trust_Boundaries_1.png)

## 探索不同的信任级别

架构师必须使用定量因素（如风险评分/容忍度、项目速度）以及主观安全目标，在组件之间选择信任配置。下面的每个示例详细说明了信任边界关系，以更好地解释信任特定资源的影响。使用从绿色（安全）到红色（危险）的颜色来标出不应信任的资源的威胁级别。

### 1. 无信任示例

如下图所示，此示例概述了一个模型，其中无论关键性或威胁级别，没有组件信任任何其他组件。这种信任配置可能用于极高风险的应用程序，其中包含非常个人的数据或重要的业务数据，或整个应用程序具有极高的业务关键性。

请注意，API 网关和计算组件都调用认证/身份服务器。这意味着即使在应用程序"内部"彼此相邻，组件之间传递的任何数据也被视为不可信。然后，计算实例必须假定一个临时身份来访问存储，因为即使用户被信任，计算实例也不被信任访问特定资源。

还要注意认证/身份服务器、临时 IAM 服务器和每个组件之间缺乏信任。虽然未在图中显示，但这将产生额外影响，如更严格的身份验证前检查，以及可能更多专用于加密操作的开销。

![跨边界无信任](../assets/Secure_Cloud_Architecture_Trust_Boundaries_2.png)

这可能是金融、军事或关键基础设施系统中应用程序所需的方法。然而，在倡导这种模型时，安全性必须谨慎，因为它将带来显著的性能和维护缺点。

|              优点               |         缺点          |
|:-------------------------------:|:---------------------:|
| 高度保证数据完整性              | 缓慢且低效            |
|         深度防御                |      复杂             |
|                                 | 可能成本更高          |

### 2. 高信任示例

接下来，考虑一种完全相反的方法，即信任一切。在这种情况下，"危险"的用户输入被直接信任并传递给高关键性的业务组件。根本不使用认证/身份资源。在这种情况下，系统遭受成功攻击的可能性更高，因为没有防范措施。此外，这种设置可能被认为是浪费的，因为认证/身份和临时 IAM 服务器并未执行其预期功能。

![跨边界完全信任](../assets/Secure_Cloud_Architecture_Trust_Boundaries_3.png)

除了最简单和最低风险的应用程序外，这种架构不太可能存在。**除非没有需要保护的敏感内容，或效率是成功的唯一指标，否则不要使用此信任边界配置**。即使在低风险应用程序中，也绝不建议信任用户输入。

| 优点      | 缺点                    |
|:---------:|:-----------------------:|
| 高效      |        不安全           |
| 简单      |   潜在地浪费            |
|           | 高风险被入侵            |

### 3. 部分信任示例

大多数应用程序将使用如下所示的信任边界配置。利用风险和攻击面分析的知识，安全性可以合理地为低风险组件或流程分配信任，并仅在必要时进行验证。这既防止了浪费宝贵的安全资源，又限制了由于额外安全开销而导致的复杂性和效率损失。

注意在此示例中，API 网关检查用户的认证/身份，然后立即将请求传递给计算实例。实例不需要重新验证，并执行其操作。然而，由于计算实例正在处理不可信的用户输入（指定为黄色表示部分信任），仍然需要假定一个临时身份来访问存储系统。

![跨边界部分信任](../assets/Secure_Cloud_Architecture_Trust_Boundaries_4.png)

从本质上讲，这种方法限制了前两个示例的优缺点。除非前面示例的优势对于满足业务需求是必要的，否则这个模型可能适用于大多数应用程序。

|                   优点                   |          缺点          |
|:----------------------------------------:|:----------------------:|
|           基于风险的安全性              | 安全性存在已知漏洞     |
| 根据关键性衡量成本/效率                 |                        |

*注意：这种信任方法与零信任不同。关于这个主题的更深入探讨，请查看 [CISA 的零信任成熟度模型](https://www.cisa.gov/sites/default/files/2023-04/zero_trust_maturity_model_v2_508.pdf)*。

### 基础设施即服务（IaaS）

在 IaaS 模型中，基础设施由云服务提供商（CSP）维护，而其他所有内容由开发者维护。这包括：

- 身份验证和授权
- 数据存储、访问和管理
- 某些网络任务（端口、网络访问控制列表等）
- 应用软件

此模型有利于开发者的可配置性和灵活性，但比其他服务模型更复杂且成本更高。它最接近正在逐渐被大公司放弃的本地部署模型。因此，将某些应用程序迁移到云 IaaS 可能比重新设计更具云原生的架构更容易。

|             优点             |            缺点           |
|:----------------------------:|:-------------------------:|
| 对大多数组件的控制权         |        成本最高           |
|   高度灵活性                 | 需要更多维护              |
| 从本地部署轻松过渡           |  复杂性高                 |

**责任几乎完全由开发者承担，必须相应地进行安全保护**。在开发 IaaS 安全策略时，必须考虑从网络访问控制、操作系统漏洞、应用程序漏洞、数据访问到身份验证/授权的所有内容。如上所述，这提供了对技术堆栈中几乎所有内容的高度控制，但如果没有充足资源用于版本升级或生命周期迁移等任务，可能非常难以维护。*（[自管理安全更新](#自管理服务的更新策略)将在下面详细讨论。）*

### 平台即服务（PaaS）

平台即服务（Platform as a Service）位于 IaaS 和 SaaS 之间。开发者控制：

- 应用程序身份验证和授权
- 应用程序软件
- 外部数据存储

它提供精简的代码托管和容器化选项，使小型开发团队或经验较少的开发者能够开始开发应用程序，同时忽略更复杂或多余的计算任务。它通常比 IaaS 更经济，同时仍保留 SaaS 系统未提供的某些控制权。然而，开发者可能会遇到所使用产品的特定限制，或兼容性问题，因为代码必须与正确的容器、框架或语言版本兼容。

此外，虽然可扩展性高度依赖于提供商和设置，但 PaaS 通常由于容器化选项和通用的、可重复的基础操作系统而提供更高的可扩展性。相比之下，IaaS 需要开发者自行构建可扩展性，而 SaaS 的性能非常依赖于特定平台。

|              优点              |              缺点              |
|:------------------------------:|:------------------------------:|
| 更易于入门和维护               | 潜在的兼容性问题               |
|       更好的可扩展性           |  提供商特定限制                |

PaaS 解决方案中的手动安全性相对较少（与 IaaS 相比）。开发者仍然必须处理特定于应用程序的身份验证和授权，以及对外部数据系统的任何访问。然而，云服务提供商负责保护容器化实例、操作系统、临时文件系统和某些网络控制。

### 软件即服务（SaaS）

软件即服务模型通常是一个几乎完整的产品，最终用户只需配置或自定义少量细节以满足其需求。用户通常控制：

- 产品边界内的配置、管理和/或代码
- 某些用户访问，如指定管理员
- 通过权限或集成的高级连接

整个技术堆栈由提供商（云服务或其他软件公司）控制，开发者只能进行相对较小的调整以满足自定义需求。这限制了成本和维护，问题通常可以通过提供商的客户支持解决，而不需要技术知识来排除整个技术堆栈的故障。

|               优点               |                缺点                |
|:--------------------------------:|:----------------------------------:|
|          维护成本低              | 受提供商约束                       |
|            成本低廉              |           控制权minimal            |
| 客户支持/故障排除                |      洞察力/监督minimal            |

由于上述缺乏控制，SaaS 的安全性同时是最简单和最困难的。开发者只需管理少量安全功能，如某些访问控制、与集成的数据信任/共享关系，以及任何自定义的安全影响。所有其他安全层都由提供商控制。这意味着任何安全修复都将超出开发者的控制范围，因此可能以不及时的方式处理，或者对最终用户（取决于安全需求）来说安全级别不够满意。然而，这些修复不需要最终用户参与和资源，从成本和维护负担的角度来看更容易。

*注意：在寻找 SaaS 解决方案时，考虑询问公司的合规性证明和对 [ISO 27001](https://www.iso.org/standard/27001) 等标准的合规证明。下面列出了主要云服务提供商的合规性网站链接，以供进一步了解。*

- [GCP](https://cloud.google.com/security/compliance/offerings)
- [AWS](https://aws.amazon.com/compliance/programs/)
- [Azure](https://servicetrust.microsoft.com/ViewPage/HomePageVNext)

### 自管理工具

从更通用的角度描述这种共享责任模型的另一种方式是按"管理"光谱对云工具进行分类。完全托管的服务除了一些编码或管理功能（SaaS）外，几乎不需要最终开发者处理，而自管理系统需要更多开销来维护（IaaS）。

AWS 提供了管理差异的绝佳示例，标识了他们的不同产品落在管理光谱的不同点上。

![共享责任模型](../assets/Secure_Cloud_Architecture_Shared_Responsibility_Model.png)

*注意：很难准确指出哪些产品被视为何种类型的服务（如 IaaS 与 PaaS）。开发者应该努力了解适用于他们正在使用的特定工具的模型。*

#### 自管理服务的更新策略

自管理工具将需要开发者和支持工程师额外的开销。根据工具的不同，可能需要基本版本更新、映像升级（如 [AMI](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AMIs.html) 或 [Compute 映像](https://cloud.google.com/compute/docs/images)）或其他操作系统级维护。使用自动化定期更新次要版本或[映像](https://docs.aws.amazon.com/systems-manager/latest/userguide/automation-tutorial-update-patch-golden-ami.html)，并在开发周期中安排刷新过时资源的时间。

#### 避免托管服务安全中的漏洞

托管服务将提供一定级别的安全性，如更新和保护运行应用程序代码的底层硬件。然而，开发团队仍然对系统中的许多安全方面负责。确保开发者根据工具选择了解哪些安全性将是他们的责任。可能以部分或全部方式由开发者负责的内容包括：

- 身份验证和授权
- 日志记录和监控
- 代码安全性（[OWASP 十大](https://owasp.org/www-project-top-ten/)）
- 第三方库补丁

参考云服务提供商提供的文档，根据所选服务了解每一方的安全责任。例如，对于无服务器函数：

- [AWS Lambda](https://docs.aws.amazon.com/lambda/latest/dg/lambda-security.html)
- [GCP Cloud Functions](https://cloud.google.com/functions/docs/securing)
- [Azure Functions](https://learn.microsoft.com/en-us/azure/architecture/serverless-quest/functions-app-security)

## 参考资料

- [安全产品设计](https://cheatsheetseries.owasp.org/cheatsheets/Secure_Product_Design_Cheat_Sheet.html)
- [CISA 安全技术参考架构](https://www.cisa.gov/sites/default/files/publications/Cloud%20Security%20Technical%20Reference%20Architecture.pdf)
