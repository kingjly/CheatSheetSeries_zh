# 密钥管理备忘录

## 1 简介

在当今时代，特别是随着 DevOps 运动的普及，密钥的使用变得无处不在。应用程序接口（API）密钥、数据库凭证、身份和访问管理（IAM）权限、安全外壳（SSH）密钥、证书等。许多组织将这些密钥以明文形式硬编码在源代码中，分散在配置文件和配置管理工具中。

组织越来越需要集中化存储、配置、审计、轮换和管理密钥，以控制对密钥的访问并防止它们泄露和危及组织安全。通常，多个服务会共享相同的密钥，这使得识别泄露或泄漏源变得困难。

本备忘录提供了正确实施密钥管理的最佳实践和指南。

## 2 通用密钥管理

以下部分介绍了与密钥管理相关的主要概念。

### 2.1 高可用性

选择一个足够健壮的技术来可靠地服务流量是至关重要的：

- 用户（如 SSH 密钥、root 账户密码）。在事件响应场景中，用户期望能够快速获得凭证，以便恢复已经离线的服务。等待凭证可能会影响运维团队的响应速度。
- 应用程序（如数据库凭证和 API 密钥）。如果服务性能不佳，可能会降低依赖应用程序的可用性或增加应用程序启动时间。

在大型组织中，这样的服务可能会收到大量请求。

### 2.2 集中化和标准化

你的 DevOps 团队用于应用程序的密钥可能与市场营销团队或 SRE 团队存储的密钥使用方式不同。当密钥使用者或生产者的需求不匹配时，你经常会发现维护不当的密钥。因此，你必须谨慎地标准化和集中化密钥管理解决方案。标准化和集中化可能意味着你需要使用多个密钥管理解决方案。例如：你的云原生开发团队选择使用云提供商提供的解决方案，而你的私有云使用第三方解决方案，并且每个人都有一个选定的密码管理器账户。
通过确保团队标准化与这些不同解决方案的交互，它们在发生事件时仍然可维护和可用。
即使公司将其密钥管理集中到一个解决方案，你通常也必须在次要密钥管理解决方案中保护主要密钥管理解决方案的主密钥。例如，你可以使用云提供商的设施来存储密钥，但该云提供商的根/管理凭证需要存储在其他地方。

标准化应包括密钥生命周期管理、身份验证、授权和密钥管理解决方案的记账，以及生命周期管理。请注意，组织应该能够立即了解密钥的用途和位置。使用的密钥管理解决方案越多，需要的文档就越多。

### 2.3 访问控制

当用户可以在密钥管理系统中读取密钥和/或更新它时，意味着密钥现在可能通过该用户和他用来接触密钥的系统泄露。
因此，工程师不应该访问密钥管理系统中的所有密钥，应该应用最小权限原则。密钥管理系统需要提供在每个对象和组件上配置细粒度访问控制的能力，以实现最小权限原则。

### 2.4 自动化密钥管理

手动维护不仅会增加泄露风险，还会引入人为错误的风险。此外，它可能会造成浪费。
因此，最好限制或消除人工与实际密钥的交互。你可以通过多种方式限制人工交互：

- **密钥流水线：** 拥有一个执行大部分密钥管理（如创建、轮换等）的密钥流水线
- **使用动态密钥：** 当应用程序启动时，它可以请求数据库凭证，动态生成的凭证将为该会话提供新的凭证。应该尽可能使用动态密钥来减少凭证重用的表面积。如果应用程序的数据库凭证被盗，重启后它们就会过期。
- **静态密钥的自动轮换：** 密钥轮换在手动实施时是一个具有挑战性的过程，可能会导致错误。因此，最好自动化密钥轮换，或至少确保该过程得到 IT 的充分支持。

轮换某些密钥，如加密密钥，可能会触发全部或部分数据重新加密。存在不同的密钥轮换策略：

- 渐进式轮换
- 为写操作引入新密钥
- 保留旧密钥用于读操作
- 快速轮换
- 计划轮换
- 等等...

### 2.5 内存中的密钥处理

通过最小化密钥在内存中的时间窗口并限制对其内存空间的访问，可以实现额外的安全级别。

根据你的应用程序的特定情况，以确保内存安全的方式实现这一点可能很困难。由于这种潜在的实现复杂性，我们首先建议你开发一个威胁模型，以清楚地展示你对应用程序部署环境的隐含假设，并了解你的对手的能力。

通常，尝试保护内存中的密钥会被认为是过度防护，因为当你评估威胁模型时，你考虑的潜在威胁行为者要么没有能力执行此类攻击，要么防御成本远超过暴露内存中密钥可能造成的影响。此外，在开发适当的威胁模型时，应该记住，如果攻击者已经可以访问处理密钥的进程的内存，那么此时安全漏洞可能已经发生。此外，应该认识到，随着像 [Rowhammer](https://arxiv.org/pdf/2211.07613.pdf) 或 [Meltdown 和 Spectre](https://meltdownattack.com/) 这样的攻击的出现，重要的是要理解操作系统本身不足以保护你的进程内存免受这些类型的攻击。这在将应用程序部署到云端时变得尤为重要。防止这些和类似攻击的唯一万无一失的方法是完全物理隔离你的进程内存与所有其他不受信任的进程。

尽管实现困难，但在高度敏感的环境中，保护内存中的密钥可以成为一个有价值的额外安全层。例如，在高级攻击者可能导致系统崩溃并获取内存转储的场景中，他们可能能够从中提取密钥。因此，对于不受信任的环境或需要严格安全性的情况，建议谨慎保护内存中的密钥。

此外，在像 C/C++ 这样的低级语言中，保护内存中的密钥相对容易。因此，即使攻击者获取内存访问权限的风险较低，实施这种做法也可能是值得的。另一方面，对于依赖垃圾收集的编程语言，保护内存中的密钥通常要困难得多。

- **结构和类：** 在 .NET 和 Java 中，不要使用不可变结构（如字符串）来存储密钥，因为无法强制它们被垃圾收集。相反，使用可以直接覆写内存的原始类型，如字节数组或字符数组。你也可以使用 Java 的 [GuardedString](https://docs.oracle.com/html/E28160_01/org/identityconnectors/common/security/GuardedString.html) 或 .NET 的 [SecureString](https://learn.microsoft.com/en-us/dotnet/api/system.security.securestring#string-versus-securestring)，它们正是为解决这个问题而设计的。

- **清零内存：** 在使用密钥后，应该将其占用的内存清零，以防止它在内存中停留，可能被访问。
    - 如果使用 Java 的 GuardedString，调用 `dispose()` 方法。
    - 如果使用 .NET 的 SecureString，调用 `Dispose()` 方法。

- **内存加密：** 在某些情况下，可能可以使用硬件或操作系统功能来加密处理密钥的进程的整个内存空间。这可以提供额外的安全层。例如，Java 中的 GuardedString 在内存中加密值，而 .NET 中的 SecureString 在 Windows 上也是如此。

记住，目标是尽可能最小化密钥在内存中以明文形式存在的时间窗口。

更详细的信息，请参见 OWASP MAS 项目的[测试内存中的敏感数据](https://mas.owasp.org/MASTG/tests/android/MASVS-STORAGE/MASTG-TEST-0011)。

### 2.6 审计

由于应用程序的性质，审计是密钥管理中不可或缺的部分。你必须安全地实施审计，以防止篡改或删除审计日志的企图。至少应审计以下内容：

- 谁请求了密钥，用于哪个系统和角色。
- 密钥请求是被批准还是被拒绝。
- 密钥何时被使用，由谁/什么使用。
- 密钥何时过期。
- 是否有尝试重用已过期的密钥。
- 是否发生过任何身份验证或授权错误。
- 密钥何时被更新，由谁/什么更新。
- 底层支持基础架构堆栈上的任何管理操作和可能的用户活动。

确保所有审计都有正确的时间戳至关重要。因此，密钥管理解决方案应在其支持的基础架构中设置适当的时间同步协议。你应监控运行该解决方案的堆栈，以检测可能的时钟偏差和手动时间调整。

### 2.7 密钥生命周期

密钥遵循一个生命周期。生命周期的阶段如下：

- 创建
- 轮换
- 吊销
- 过期

#### 2.7.1 创建

新密钥必须安全生成，并在密码学上对其用途足够强健。密钥必须分配最小的权限以启用其所需的使用/角色。

你应该安全地传输凭证，理想情况下，在请求用户账户时不要与用户名一起发送密码。相反，应通过安全信道（例如双向认证连接）或侧信道（如推送通知、短信、电子邮件）发送密码。请参考[多因素认证备忘录](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet)了解每个信道的优缺点。

应用程序可能不会从多个通信信道中受益，因此你必须安全地配置凭证。

有关密钥创建的更多技术建议，请参见 [Open CRE 项目关于密钥查找](https://www.opencre.org/cre/223-780)。

#### 2.7.2 轮换

你应定期轮换密钥，使任何被盗的凭证只能在短时间内使用。定期轮换还将减少用户重新使用凭证等不良习惯的倾向。

根据密钥的功能和其保护的对象，生命周期可能从几分钟（想想具有完美前向保密性的端到端加密聊天）到几年（考虑硬件密钥）不等。

用户凭证不在常规轮换范围内。根据 [NIST 建议](https://pages.nist.gov/800-63-FAQ/#q-b05)，这些凭证仅在有可疑或有证据表明其已被泄露时才应轮换。

#### 2.7.3 吊销

当密钥不再需要或可能已泄露时，你必须安全地吊销它们以限制访问。对于（TLS）证书，这还涉及证书吊销。

#### 2.7.4 过期

在可能的情况下，你应创建在定义的时间后过期的密钥。这种过期可以是由密钥消费系统主动过期，或在密钥管理系统中设置过期日期，触发支持流程进行密钥轮换。
你应通过密钥管理解决方案应用策略，确保凭证仅在适合该类型凭证的有限时间内可用。应用程序应在信任密钥之前验证密钥是否仍然有效。

### 2.8 传输层安全（TLS）无处不在

永远不要以明文传输密钥。在当今这个 TLS 被普遍采用的时代，这是没有借口的。

此外，你可以有效地使用密钥管理解决方案来配置 TLS 证书。

### 2.9 停机、紧急访问、备份和恢复

考虑密钥管理服务可能因各种原因（如计划的维护停机）而不可用的可能性。如果你之前没有获取凭证，可能无法检索恢复服务所需的凭证。因此，根据早期的指标和审计日志仔细选择维护窗口。

接下来，系统的备份和恢复程序应定期测试和审计其安全性。关于备份和恢复，确保：

- 建立并定期执行自动备份程序；根据密钥数量和其生命周期确定备份和快照的频率。
- 频繁测试恢复程序，以保证备份完整。
- 加密备份并将其放在访问权限受限的安全存储上。监控备份位置的（未授权）访问和管理操作。

最后，你应实施紧急（"破玻璃"）流程，以在系统因常规维护以外的原因不可用时恢复服务。因此，紧急破玻璃凭证应定期在次要密钥管理系统中安全备份，并定期测试以验证其有效性。

### 2.10 策略

在组织范围内一致地执行定义密码最低复杂性要求和批准的加密算法的策略。使用集中式密钥管理解决方案可以帮助公司实施这些策略。

此外，制定组织范围的密钥管理策略可以帮助强制执行本备忘录中定义的最佳实践。

### 2.11 元数据：准备移动密钥

密钥管理解决方案应提供存储关于密钥的至少以下元数据的能力：

- 创建/使用/归档/轮换/删除的时间
- 谁创建/使用/归档/轮换/删除了它（例如，实际生产者和使用生产方法的工程师）
- 什么创建/使用/归档/轮换/删除了它
- 遇到密钥问题或有疑问时联系谁
- 密钥的用途（例如，指定的预期使用者和密钥目的）
- 密钥的类型（例如 AES 密钥、HMAC 密钥、RSA 私钥）
- 需要轮换的时间，如果是手动完成

注意：如果不存储关于密钥的元数据也不准备移动，你将增加供应商锁定的可能性。

## 3 持续集成（CI）和持续部署（CD）

构建、测试和部署变更通常需要访问多个系统。持续集成（CI）和持续部署（CD）工具通常存储密钥以提供应用程序配置或在部署期间。或者，它们与密钥管理系统进行大量交互。各种最佳实践可以帮助简化 CI/CD 中的密钥管理；我们将在本节中讨论其中的一些。

### 3.1 加固你的 CI/CD 流水线

CI/CD 工具定期消耗（高权限）凭证。确保流水线不能被轻易黑客攻击或被员工滥用。以下是一些可以帮助你的指南：

- 将 CI/CD 工具视为生产环境：加固它，修补它，并加固底层基础架构和服务。
- 建立安全事件监控。
- 实施最小权限访问：开发人员不需要能够管理项目。相反，他们只需要能够执行必需的功能，如设置流水线、运行流水线和处理代码。管理任务可以快速地使用配置即代码（configuration-as-code）在 CI/CD 系统使用的单独存储库中更新其配置。不需要可能有权访问密钥的特权角色。
- 确保流水线输出不会泄露密钥，并且无法使用调试工具监听生产流水线。
- 确保无法对 CI/CD 系统的任何运行器和工作进程执行 exec 操作。
- 建立适当的身份验证、授权和记账。
- 确保只有经批准的流程可以创建流水线，包括合并请求/拉取请求步骤，以确保创建的流水线经过安全审查。

### 3.2 密钥应该放在哪里？

有多种地方可以存储执行 CI/CD 操作的密钥：

- 作为 CI/CD 工具的一部分：你可以在 [GitLab](https://docs.gitlab.com/charts/installation/secrets.html)/[GitHub](https://docs.github.com/en/actions/security-guides/encrypted-secrets)/[Jenkins](https://www.jenkins.io/doc/developer/security/secrets/) 中存储密钥。这与将其提交到代码中是不同的。
- 作为密钥管理系统的一部分：你可以在密钥管理系统中存储密钥，如云提供商提供的设施（[AWS 密钥管理器](https://aws.amazon.com/secrets-manager/)、[Azure 密钥保管库](https://azure.microsoft.com/nl-nl/services/key-vault/)、[Google 密钥管理器](https://cloud.google.com/secret-manager)），或其他第三方设施（[Hashicorp Vault](https://www.vaultproject.io/)、[Conjur](https://www.conjur.org/)、[Keeper](https://www.keepersecurity.com/)）。在这种情况下，CI/CD 流水线工具需要凭证以连接这些密钥管理系统以获取密钥。有关使用云提供商的密钥管理系统的更多详细信息，请参见[云提供商](#4-云提供商)部分。

另一种选择是使用 CI/CD 流水线利用密钥管理系统的"即服务加密"来加密密钥。然后 CI/CD 工具可以将加密的密钥提交到 git，消费服务可以在部署时获取并再次解密。有关更多详细信息，请参见第 3.6 节。

注意：并非所有密钥都必须在 CI/CD 流水线中才能到达实际部署。相反，确保部署的服务在其自身生命周期（如部署、运行时和销毁）中处理部分密钥管理。

#### 3.2.1 作为 CI/CD 工具的一部分

当密钥是 CI/CD 工具的一部分时，意味着这些密钥暴露给你的 CI/CD 作业。CI/CD 工具可以包括 GitHub 密钥、GitLab 存储库密钥、Microsoft Azure DevOps 中的环境变量/变量组、Kubernetes 密钥等。
这些密钥通常可由具有授权的人配置/查看（例如 GitHub 中的维护者、GitLab 中的项目所有者、Jenkins 中的管理员等），这与以下最佳实践相符：

- 无"大密钥"：确保 CI/CD 工具中的密钥不是长期的、没有广泛的影响范围且没有高价值。还要限制共享密钥（例如，绝不为所有管理用户使用一个密码）。
- 现状/目标：清楚地了解哪些用户可以查看或更改密钥。通常，GitLab/GitHub 项目的维护者可以查看或以其他方式提取其密钥。
- 减少可以对项目执行管理任务的人数，以限制暴露。
- 日志和警报：收集 CI/CD 工具的所有日志，并制定规则以检测密钥提取或滥用，无论是通过 Web 界面访问还是在双重 base64 编码或使用 OpenSSL 加密时转储。
- 轮换：定期轮换密钥。
- 分支不应泄露：验证存储库的分支或作业定义的副本不会复制密钥。
- 文档：确保记录你在 CI/CD 工具中存储的密钥及其原因，以便在需要时可以轻松迁移。

#### 3.2.2 在密钥管理系统中存储

自然地，你可以在指定的密钥管理解决方案中存储密钥。例如，你可以使用（云）基础架构提供商提供的解决方案，如 [AWS 密钥管理器](https://aws.amazon.com/secrets-manager/)、[Google 密钥管理器](https://cloud.google.com/secret-manager)或 [Azure 密钥保管库](https://azure.microsoft.com/nl-nl/services/key-vault/)。你可以在本备忘录的[第 4 节](#4-云提供商)中找到有关这些的更多信息。另一个选择是专用密钥管理系统，如 [Hashicorp Vault](https://www.vaultproject.io/)、[Keeper](https://www.keepersecurity.com/)、[Conjur](https://www.conjur.org/)。

以下是 CI/CD 与这些系统交互的一些注意事项。确保处理好以下内容：

- 轮换/临时性：用于向密钥管理系统进行身份验证的 CI/CD 工具凭证经常轮换，并在作业完成后过期。
- 授权范围：限制 CI/CD 工具使用的凭证（如角色、用户等）的范围，仅授权 CI/CD 工具执行作业所需的密钥和服务。
- 调用者归属：CI/CD 工具使用的凭证仍然保留调用密钥管理解决方案者的归属。确保可以将 CI/CD 工具发出的任何调用归因于请求 CI/CD 工具操作的人员或服务。如果无法通过密钥管理器的默认配置实现，请确保在请求参数方面建立关联。
- 上述所有内容：仍然遵循第 3.2.1 节中列出的注意事项：日志和警报、注意分支等。
- 备份：对产品关键操作的密钥进行备份到单独的存储（例如冷存储），尤其是加密密钥。

#### 3.2.3 完全不由 CI/CD 触及

密钥不一定需要通过 CI/CD 流水线传递给密钥的消费者。当密钥的消费者自行检索密钥时，情况甚至更好。在这种情况下，CI/CD 流水线仍然需要指示编排系统（例如 [Kubernetes](https://kubernetes.io/)）使用特定服务账户调度特定服务，消费者可以通过该服务账户检索所需的密钥。这样，CI/CD 工具仍然拥有编排平台的凭证，但不再直接访问密钥本身。关于这些凭证类型的注意事项与第 3.2.2 节中描述的类似。

### 3.3 CI/CD 工具的身份验证和授权

CI/CD 工具应具有专用服务账户，该账户只能在所需密钥或密钥消费者的编排范围内操作。此外，CI/CD 流水线运行应易于归因于定义作业或触发作业的人员，以便检测谁试图窃取或操纵密钥。使用基于证书的身份验证时，流水线调用者的身份应成为证书的一部分。如果使用令牌向提到的系统进行身份验证，请确保设置请求这些操作的主体（例如用户或作业创建者）。

定期验证系统是否仍然符合这一要求，以便可以有效地对可疑操作进行日志记录、归因和安全警报。

### 3.4 日志记录和记账

攻击者可以使用 CI/CD 工具提取密钥。例如，他们可能使用管理界面或作业创建来通过加密或双重 base64 编码窃取密钥。因此，你应该记录 CI/CD 工具中的每个操作。你应该在流水线工具及其管理界面的每个非标准操作上定义安全警报规则，以监控密钥使用情况。
日志应可查询至少 90 天，并长期存储在冷存储中。安全团队可能需要时间了解攻击者如何使用 CI/CD 工具窃取或操纵密钥。

### 3.5 轮换与动态创建

你可以利用 CI/CD 工具轮换密钥或指示其他组件进行密钥轮换。例如，CI/CD 工具可以请求密钥管理系统或另一个应用程序轮换密钥。或者，CI/CD 工具或另一个组件可以设置动态密钥：消费者在其生命周期内使用的所需密钥。当消费者不再存在时，密钥将失效。这个过程减少了密钥泄露的可能性，并允许轻松检测滥用情况。如果攻击者从消费者 IP 以外的任何地方使用密钥，你可以轻松检测到。

### 3.6 流水线创建的密钥

你可以使用流水线工具生成密钥，并直接将其提供给由工具部署的服务，或将密钥提供给密钥管理解决方案。另外，密钥可以加密存储在 git 中，使密钥及其元数据尽可能接近开发人员的日常工作场所。存储在 git 中的密钥确实要求开发人员不能自行解密密钥，并且每个密钥的消费者都有其密钥的加密变体。例如：密钥应针对每个 DTAP 环境不同，并使用不同的密钥加密。对于每个环境，只有该环境中指定的消费者才能解密特定的密钥。密钥不会跨环境泄露，并且仍然可以轻松地存储在代码旁边。

密钥的消费者现在可以使用第 5.2 节中描述的边车（sidecar）来解密密钥。消费者不是检索密钥，而是利用边车解密密钥。

当流水线自行创建密钥时，确保涉及的脚本或二进制文件遵守密钥生成的最佳实践。最佳实践包括安全随机性、适当的密钥创建长度等，并且密钥是基于存储在 git 或其他地方的明确定义的元数据创建的。

## 4 云提供商

对于云提供商，至少有四个essential主题需要探讨：

- 指定的密钥存储/管理解决方案。你使用哪种服务？
- 信封加密和客户端加密
- 身份和访问管理：减小影响范围
- API 配额或服务限制

### 4.1 要使用的服务

在任何环境中，最好使用指定的密钥管理解决方案。大多数云提供商至少提供一种密钥管理服务。当然，也可以在云计算资源中运行不同的密钥管理解决方案（例如 HashiCorp Vault 或 Conjur）。本节将考虑云提供商的服务产品。

有时可以通过云提供商提供的服务或（自定义构建的）函数自动轮换密钥。通常，你应该优先选择云提供商的解决方案，因为入门门槛较低，配置错误的风险较小。如果使用自定义解决方案，请确保执行轮换的函数的角色只能由该函数承担。

### 4.2 信封加密和客户端加密

本节将描述密钥的加密方式以及如何在云中管理这些加密的密钥。

#### 4.2.1 客户端加密与服务器端加密

服务器端密钥加密确保云提供商负责在存储中加密密钥。这样密钥在静态时就得到保护。静态加密通常不需要额外工作，只需选择用于加密的密钥（参见第 4.2.2 节）。然而，当你将密钥提交给另一个服务时，它将不再加密。在与目标服务或人工用户共享之前，它会被解密。

客户端密钥加密确保密钥保持加密状态，直到你主动解密。这意味着它仅在到达消费者时才被解密。你需要有一个适当的加密系统来满足这一需求。考虑使用安全配置的 PGP 等机制，以及其他更可扩展且相对易用的系统。客户端加密可以提供端到端的密钥加密：从生产者到消费者。

#### 4.2.2 自带密钥（BYOK）与云提供商密钥

当你对静态密钥进行加密时，问题是：你想使用哪个密钥？你对云提供商的信任越少，你就越想自行管理。

通常，你可以使用密钥管理服务中管理的密钥加密密钥，或使用云提供商的密钥管理解决方案加密密钥。云提供商密钥管理解决方案提供的密钥可以由云提供商管理，也可以由你自己管理。行业标准将后者称为"自带密钥"（BYOK）。你可以直接在密钥管理解决方案中导入或生成此密钥，或使用云提供商支持的云 HSM。

然后，你可以使用自己的密钥或提供商的客户主密钥（CMK）加密密钥管理解决方案的数据密钥。数据密钥反过来加密密钥。通过管理 CMK，你可以控制密钥管理解决方案中的数据密钥。

虽然通常可以在所有提供商（[AWS](https://docs.aws.amazon.com/kms/latest/developerguide/importing-keys.html)、[Azure](https://docs.microsoft.com/en-us/azure/key-vault/keys/byok-specification)、[GCP](https://cloud.google.com/kms/docs/key-import)）中导入自己的密钥材料，但除非你知道自己在做什么，并且你的威胁模型和策略要求这样做，否则由于其复杂性和使用难度，这不是推荐的解决方案。

### 4.3 身份和访问管理（IAM）

IAM 适用于本地和云设置：要有效管理密钥，你需要设置合适的访问策略和角色。设置这一点不仅仅是关于密钥的策略；它应包括全面的 IAM 强化，否则可能允许特权提升攻击。确保永远不要允许开放的"传递角色"权限或不受限制的 IAM 创建权限，因为这些可能使用或创建可访问密钥的凭证。接下来，确保严格控制可以模拟服务账户的对象：攻击者利用服务器漏洞是否可以访问你的机器角色？数据管道工具的服务角色是否可以轻松访问密钥？确保在威胁模型中包含每个云组件的 IAM（例如，问问自己：如何使用此组件提升权限？）。请参阅[此博客文章](https://xebia.com/ten-pitfalls-you-should-look-out-for-in-aws-iam/)，其中有多个包含示例的注意事项。

有效利用 IAM 主体的临时性：例如，确保只有需要的特定角色和服务账户可以访问密钥。监控这些账户，以便你可以追踪谁或什么使用它们访问密钥。

接下来，确保限定对密钥的访问范围：不应该简单地允许访问所有密钥。在 GCP 和 AWS 中，你可以创建细粒度的访问策略，确保主体不能一次性访问所有密钥。在 Azure 中，访问密钥保管库意味着访问该密钥保管库中的所有密钥。因此，在 Azure 中工作时，拥有单独的密钥保管库以隔离访问至关重要。

### 4.4 API 限制

云服务通常在给定期间内提供有限数量的 API 调用。当你遇到这些限制时，可能会（拒绝服务）攻击自己。这些限制大多适用于每个账户、项目或订阅，因此分散工作负载以相应地限制影响范围。此外，一些服务可能支持数据密钥缓存，防止对密钥管理服务 API 的负载（例如参见 [AWS 数据密钥缓存](https://docs.aws.amazon.com/encryption-sdk/latest/developer-guide/data-key-caching.html)）。某些服务可以利用内置的数据密钥缓存。[S3 就是这样的一个例子](https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucket-key.html)。

## 5 容器与编排器

你可以通过多种方式为容器添加密钥：构建时（不推荐）和编排/部署期间。

### 5.1 密钥注入（文件、内存）

在 Docker 容器内向应用程序提供密钥有三种方式。

- 挂载卷（文件）：使用这种方法，我们将密钥保存在特定的配置/密钥文件中，并将该文件作为挂载卷挂载到我们的实例上。确保这些挂载由编排器挂载，而不是内置的，因为这会导致密钥随容器定义泄露。相反，确保编排器在需要时挂载卷。
- 从密钥存储中获取（内存）：边车应用/容器直接从密钥管理服务获取其所需的密钥，而无需处理 Docker 配置。这种解决方案允许你使用动态构建的密钥，而无需担心密钥在文件系统中可见或从检查 Docker 容器的环境变量中泄露。
- 环境变量：我们可以直接将密钥作为 Docker 容器配置的一部分提供。注意：密钥本身不应使用 Docker ENV 或 Docker ARG 命令硬编码，因为这些可能会随容器定义轻易泄露。另请参阅 [WrongSecrets](https://github.com/OWASP/wrongsecrets) 上的 Docker 挑战。相反，让编排器用实际密钥覆盖环境变量，并确保这不是硬编码的。此外，环境变量通常可被所有进程访问，并可能包含在日志或系统转储中。因此，除非其他方法不可行，否则不建议使用环境变量。

### 5.2 短生命周期边车容器

要注入密钥，你可以创建短生命周期的边车容器，从某个远程端点获取密钥，然后将它们存储在挂载到原始容器的共享卷上。原始容器现在可以使用挂载卷中的密钥。使用这种方法的好处是，我们不需要集成任何第三方工具或代码来获取密钥。一旦边车获取了密钥，它就会终止。这方面的示例包括 [Vault Agent 边车注入器](https://developer.hashicorp.com/vault/docs/platform/k8s/injector)和 [Conjur 密钥提供程序](https://github.com/cyberark/secrets-provider-for-k8s)。通过将密钥挂载到与 Pod 共享的卷上，Pod 中的容器可以在不知道密钥管理器的情况下使用密钥。

### 5.3 内部与外部访问

你应该仅将密钥暴露给容器和部署表示之间的通信机制（例如 Kubernetes Pod）。切勿通过部署或编排器之间共享的外部访问机制（例如共享卷）暴露密钥。

当编排器存储密钥（例如 Kubernetes Secrets）时，确保编排器的存储后端已加密，并且你能很好地管理密钥。有关更多信息，请参阅 [Kubernetes 安全备忘录](Kubernetes_Security_Cheat_Sheet.md)。

## 6 实施指导

在本节中，我们将讨论实施细节。请注意，始终最好参考所选密钥管理系统的官方文档进行实际实施，因为它比本备忘录等任何二手文档都更加最新。

### 6.1 密钥材料管理策略

密钥材料管理在[密钥管理备忘录](Key_Management_Cheat_Sheet.md)中有详细讨论。

### 6.2 动态与静态使用场景

我们看到动态密钥的以下使用场景，包括但不限于：

- 用于次要服务的短期密钥（如凭证或 API 密钥），表达将主服务（如消费者）连接到该服务的意图。
- 用于保护和保障内存和运行时通信过程的短期完整性和加密控制。例如，只需在单个会话或单个部署生命周期内存在的加密密钥。
- 在服务部署期间为与部署者和支持基础设施交互而创建的短期凭证。

请注意，这些动态密钥通常需要与我们要连接的服务一起创建。要创建这些类型的动态密钥，我们通常需要长期静态密钥来创建动态密钥本身。其他静态使用场景包括：

- 由于与同一服务的其他实例交互的使用性质，需要比单个部署生命周期更长的密钥材料（例如存储加密密钥、TLS PKI 密钥）
- 连接到不支持创建临时角色或凭证的服务的密钥材料或凭证。

### 6.3 确保限制措施到位

密钥不应被每个人和每个事物都能检索。始终确保设置防护措施：

- 是否有机会创建访问策略？确保制定策略以限制可以读取或写入密钥的实体数量。同时，编写策略时要便于扩展，且不过于复杂。
- 在密钥管理解决方案中是否无法减少对某些密钥的访问？考虑通过使用单独的密钥管理解决方案来分隔生产和开发密钥。然后，减少对生产密钥管理解决方案的访问。

### 6.4 安全事件监控至关重要

持续监控谁/什么、来自哪个 IP、使用何种方法访问密钥。需要关注各种模式，包括但不限于：

- 监控谁在密钥管理系统中访问密钥：这是否是正常行为？如果 CI/CD 凭证从与 CI/CD 系统运行位置不同的 IP 访问密钥管理解决方案，则提供安全警报并假定密钥已泄露。
- 监控需要密钥的服务（如果可能），例如，密钥用户是否来自预期的 IP，使用预期的用户代理。如果不是，则发出警报并假定密钥已泄露。

### 6.5 可用性

确保你的密钥管理解决方案易于使用，因为你不希望人们因复杂性而绕过它或无效地使用它。这种可用性需要：

- 轻松添加新密钥和移除无效密钥。
- 易于与现有软件集成：应该很容易将应用程序作为密钥管理系统的消费者。例如，应提供 SDK 或简单的边车容器以与密钥管理系统通信，使现有软件解耦且无需大量修改。你可以在 AWS、Google 和 Azure SDK 中找到此类示例。这些 SDK 允许应用程序与各自的密钥管理解决方案交互。你还可以在 HashiCorp Vault 软件集成和 [Vault Agent 边车注入器](https://developer.hashicorp.com/vault/docs/platform/k8s/injector)以及 Conjur 集成和 [Conjur 密钥提供程序](https://github.com/cyberark/secrets-provider-for-k8s)中找到类似示例。
- 对密钥管理组织及其流程有清晰的理解至关重要。

## 7 加密

密钥管理与加密密不可分。毕竟，密钥必须以加密形式存储在某处以保护其机密性和完整性。

### 7.1 要使用的加密类型

只要提供足够的安全性，包括对量子计算攻击的充分抵抗，你可以使用各种加密类型来保护密钥。鉴于这是一个不断发展的领域，最好查看像 [keylength.com](https://www.keylength.com/en/4/) 这样的资源，它列举了现有标准的加密类型和密钥长度的最新建议，以及枚举量子抗性算法的 NSA 的[商业国家安全算法套件 2.0](https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/CSA_CNSA_2.0_ALGORITHMS_.PDF)。

请注意，在所有情况下，我们最好选择能同时提供加密和机密性的算法，如使用 GCM（[伽罗瓦计数器模式](https://en.wikipedia.org/wiki/Galois/Counter_Mode)）的 AES-256，或根据该领域最佳实践混合使用 ChaCha20 和 Poly1305。

### 7.2 收敛加密

[收敛加密](https://en.wikipedia.org/wiki/Convergent_encryption)确保给定的明文和其密钥会产生相同的密文。这可以帮助检测密钥可能的重复使用，从而导致相同的密文。

启用收敛加密的挑战在于，它允许攻击者使用系统生成一组加密字符串，这些字符串可能最终指向相同的密钥，使攻击者能够推导出明文密钥。给定算法和密钥，如果你使用的收敛加密系统在加密期间有足够的资源挑战，则可以缓解这种风险。另一个有助于降低风险的因素是确保密钥具有足够的长度，这将进一步阻碍可能需要的猜测迭代时间。

### 7.3 在哪里存储加密密钥？

除非这些密钥本身已加密（参见信封加密），否则不应将密钥存储在它们加密的密钥旁边。首先请查阅[密钥管理备忘录](Key_Management_Cheat_Sheet.md)，了解在哪里以及如何存储加密和可能的 HMAC 密钥。

### 7.4 作为服务的加密（EaaS）

EaaS 是一种用户订阅基于云的加密服务的模型，无需在自己的系统上安装加密。使用 EaaS，你可以获得以下好处：

- 静态加密
- 传输中加密（TLS）
- 密钥处理和加密实现由加密服务负责，而非开发人员
- 提供商可以添加更多与敏感数据交互的服务

## 8 检测

在密钥检测方面有许多方法，并且有一些非常有用的开源项目可以提供帮助。[Yelp Detect Secrets](https://github.com/Yelp/detect-secrets) 项目已经成熟，能够匹配大约 20 种密钥。有关帮助你进行密钥检测的其他工具的更多信息，请查看 GitHub 上的[密钥检测](https://github.com/topics/secrets-detection)主题。

### 8.1 常规检测方法

左移和 DevSecOps 原则同样适用于密钥检测。以下常规方法旨在更早地考虑密钥并随时间演进实践：

- 创建标准测试密钥并在整个组织中通用。这允许通过仅需要跟踪每种密钥类型的单个测试密钥来减少误报。
- 考虑在开发人员级别启用密钥检测，以避免在提交/PR 之前将密钥检入代码，可以在 IDE 中、作为测试驱动开发的一部分，或通过预提交钩子实现。
- 使密钥检测成为威胁模型的一部分。在威胁建模练习中将密钥视为攻击面的一部分。
- 经常评估检测实用程序和相关签名，以确保它们符合预期。
- 考虑使用多个检测实用程序，并关联/去重结果以识别潜在的检测弱点区域。
- 探索熵和检测易用性之间的平衡。具有一致格式的密钥更容易检测，误报率较低，但你也不希望仅因为密钥不匹配检测规则就遗漏人工创建的密码。

### 8.2 要检测的密钥类型

存在许多类型的密钥，你应该考虑每种类型的签名以确保所有密钥的准确检测。较常见的类型包括：

- 高可用性密钥（难以轮换的令牌）
- 应用程序配置文件
- 连接字符串
- API 密钥
- 凭证
- 密码
- 双因素认证密钥
- 私钥（例如 SSH 密钥）
- 会话令牌
- 特定平台的密钥类型（例如 Amazon Web Services、Google Cloud）

若要更有趣地了解密钥并练习发现它们，请查看 [Wrong Secrets](https://owasp.org/www-project-wrongsecrets/) 项目。

### 8.3 检测生命周期

密钥就像任何其他授权令牌。它们应该：

- 仅在必要时存在（经常轮换）
- 具有自动轮换的方法
- 仅对需要它们的人可见（最小权限）
- 可撤销（包括记录尝试使用已撤销密钥的行为）
- 永远不要被记录（必须实施加密或屏蔽方法，以避免记录明文密钥）

为密钥生命周期的每个阶段创建检测规则。

### 8.4 密钥检测文档

创建并定期更新文档，以告知开发者社区贵组织可用的程序和系统，以及你对密钥管理的期望、如何测试密钥，以及在检测到密钥时应该怎么做。

文档应该：

- 存在并经常更新，尤其是对应事件的响应
- 包括以下信息：
    - 谁有权访问密钥
    - 如何轮换
    - 密钥轮换期间可能被破坏的上游或下游依赖项
    - 事件期间的联系人
    - 暴露的安全影响

- 根据威胁风险、数据分类等识别可能需要不同处理的密钥。

## 9 事件响应

在密钥暴露事件中快速响应可能是密钥管理中最关键的考虑因素之一。

### 9.1 文档

密钥暴露事件的事件响应应确保责任链中的每个人都知晓并理解如何响应。这包括应用程序创建者（开发团队的每个成员）、信息安全和技术领导层。

文档必须包括：

- 如何测试密钥和密钥处理，尤其是在业务连续性审查期间。
- 检测到密钥时通知谁。
- 遏制的步骤
- 事件期间要记录的信息

### 9.2 补救

事件响应的主要目标是快速响应和遏制。

遏制应遵循以下程序：

1. 撤销：已暴露的密钥应立即撤销。必须能够快速取消授权密钥，并且系统必须能够识别撤销状态。
2. 轮换：必须能够快速创建并实施新密钥，最好通过自动化流程以确保可重复性、低实施错误率和最小权限（不直接人工可读）。
3. 删除：已撤销/轮换的密钥必须立即从暴露的系统中移除，包括在代码或日志中发现的密钥。代码中的密钥可以将提交历史压缩到引入密钥之前，但这可能会引入其他问题，因为它重写了 git 历史并会破坏对给定提交的任何其他链接。如果决定这样做，请注意后果并相应地规划。日志中的密钥必须有一个在保持日志完整性的同时移除密钥的流程。
4. 日志记录：事件响应团队必须能够访问密钥生命周期的相关信息，以帮助遏制和补救，包括：
    - 谁有访问权？
    - 他们何时使用？
    - 上次轮换是何时？

### 9.3 日志记录

密钥使用日志记录的其他注意事项应包括：

- 用于事件响应的日志记录应集中在事件响应（IR）团队可访问的单一位置
- 在紫队演习期间确保日志记录信息的保真度，例如：
    - 应该记录什么？
    - 实际记录了什么？
    - 我们是否有足够的警报来确保这一点？

考虑使用标准化的日志格式和词汇，如[日志词汇备忘录](Logging_Vocabulary_Cheat_Sheet.md)，以确保记录所有必要的信息。

## 10 多云环境中的密钥管理

### 10.1 引言

在多云环境中管理密钥由于云提供商及其各自服务的多样性，带来了独特的挑战。本节讨论跨多个云提供商管理密钥的挑战和最佳实践。

### 10.2 挑战

1. **多样的 API 和接口**：每个云提供商都有自己的 API 和接口来管理密钥，这可能导致跨多个提供商集成和管理密钥的复杂性。
2. **不一致的安全策略**：不同的云提供商可能有不同的安全策略和实践，这使得在所有环境中执行一致的安全标准变得具有挑战性。
3. **密钥轮换**：确保跨多个云提供商一致且安全地轮换密钥可能很困难，尤其是当每个提供商的密钥轮换机制不同时。
4. **访问控制**：跨多个云提供商管理密钥的访问控制可能很复杂，因为每个提供商可能有不同的访问控制机制和策略。
5. **审计和监控**：由于日志记录和监控功能的差异，确保跨多个云提供商全面审计和监控密钥访问和使用可能具有挑战性。

### 10.3 最佳实践

1. **使用集中式密钥管理解决方案**：实施可以与多个云提供商集成的集中式密钥管理解决方案。这可以帮助标准化密钥管理并在所有环境中执行一致的安全策略。例如 HashiCorp Vault 和 CyberArk Conjur。
2. **标准化安全策略**：为跨所有云提供商管理密钥定义并执行标准化的安全策略。这包括密钥轮换、访问控制和审计的策略。
3. **自动密钥轮换**：实施自动密钥轮换流程，确保跨所有云提供商一致且安全地轮换密钥。使用工具和脚本自动化轮换过程，降低人为错误风险。
4. **实施细粒度访问控制**：使用细粒度访问控制机制，根据最小权限原则限制对密钥的访问。确保跨所有云提供商一致地执行访问控制策略。
5. **启用全面的审计和监控**：在所有云提供商中实施对密钥访问和使用的全面审计和监控。使用集中式日志记录和监控解决方案来聚合和分析来自多个提供商的日志。

### 10.4 参考资料

- [HashiCorp Vault](https://www.vaultproject.io/)
- [CyberArk Conjur](https://www.conjur.org/)
- [AWS 密钥管理器](https://aws.amazon.com/secrets-manager/)
- [Azure 密钥保管库](https://azure.microsoft.com/en-us/services/key-vault/)
- [Google Cloud 密钥管理器](https://cloud.google.com/secret-manager)

## 11 相关备忘录和延伸阅读

- [密钥管理备忘录](Key_Management_Cheat_Sheet.md)
- [日志备忘录](Logging_Cheat_Sheet.md)
- [密码存储备忘录](Password_Storage_Cheat_Sheet.md)
- [加密存储备忘录](Cryptographic_Storage_Cheat_Sheet.md)
- [OWASP WrongSecrets 项目](https://github.com/OWASP/wrongsecrets/)
- [博客：密钥管理的 10 个指针](https://xebia.com/blog/secure-deployment-10-pointers-on-secrets-management/)
- [博客：从构建到运行：安全部署的指针](https://xebia.com/from-build-to-run-pointers-on-secure-deployment/)
- [GitHub 上的密钥检测工具列表](https://github.com/topics/secrets-detection)
- [NIST SP 800-57 密钥管理建议](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)
- [OpenCRE 密钥相关引用](https://opencre.org/cre/223-780)
